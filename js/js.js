// Ванильный Java Script
var js1 = {
	"Ещё здесь пусто, человек":"Иди гуляй в свой дивный век"
};

// Работа с DOM
var js2 = {
	"<h1>Навигация по DOM-элементов</h1>":"<h4>div.parentNode</h4><p>обращение к родительскому узлу.</p><h4>div.previousSibling</h4><p>обращение к предыдущему узлу.</p><h4>div.nextSibling</h4><p>обращение к следующему узлу.</p><h4>div.firstChild</h4><p>первый дочерний элемент.</p><h4>div.childNodes</h4><p>коллекция, хранящая все дочерние элементы, включая текстовые (псевдомассив).</p><h4>div.lastChild</h4><p>последний дочерний элемент.</p>",
  "<h1>Навигация по элементам</h1>":"<h4>div.parentElement</h4><p>обращение к родительскому элементу.</p><h4>div.previousElementSibling</h4><p>обращение к предыдущему элементу.</p><h4>div.nextElementSibling</h4><p>обращение к следующему элементу.</p><h4>div.firstElementChild</h4><p>первый дочерний элемент.</p><h4>div.children[]</h4><p>коллекция, хранящая только дочерние узлы-элементы.</p><h4>div.lastElementChild</h4><p>последний дочерний элемент.</p>",
  "<h1>Поиск элемента по ID</h1>":"<h4>document.getElementById('id')</h4><p>Если элементу назначен специальный атрибут id, то можно получить его прямо по переменной с именем из значения id.</p>",
  "<h1>Поиск элемента по Тегу</h1>":"<h4>elem.getElementsByTagName('tag')</h4><p>Метод ищет все элементы с заданным тегом внутри элемента и возвращает их в виде списка. Регистр тега не имеет значения.</p>",
  "<h1>Поиск элемента по Имени</h1>":"<h4>document.getElementsByName('name')</h4><p>Метод ищет все элементы, атрибут name которых будет совпадает с переданным в метод.</p>",
  "<h1>Поиск элемента по Классу</h1>":"<h4>elem.getElementsByClassName('class')</h4><p>Метод ищет все элементы, класс которых совпадает с переданным в метод.</p>",
  "<h1>Поиск элемента по Селектору</h1>":"<h4>elem.querySelector('selector')</h4><p>Метод возвращает самый первый элемент внутри elem, удовлетворяющий CSS-селектору, переданному в метод.</p>",
  "<h1>Множественный поиск элемента по селектору</h1>":"<h4>elem.querySelectorAll('selector')</h4><p>Метод возвращает все элементы внутри elem, удовлетворяющие CSS-селектору, переданному в метод.</p>",
  "<h1>Проверка элемента на селектор</h1>":"<h4>elem.matches</h4><p>Данный метод ничего не ищет, а проверяет, удовлетворяет ли elem селектору css. Он возвращает true либо false. Используется для фильтрации выборки элементов.</p>",
  "<h1>Поиск элемента вверх</h1>":"<h4>elem.closest</h4><p>Данный метод ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор.</p>",
  "<h1>Свойства DOM-узлов </h1>":"<h4>nodeName</h4><p>возвращает название тега (название узла)</p><h4>tagName</h4><p>возвращает название тега (название тега)</p><h4>innerHTML</h4><p>позволяет получить или установить содержимое элемента в виде строки (HTML-код)</p><h5>Тонкости работы innerHTML</h5><p>innerHTML += перезапишет содержимое, а не добавит дополнительное</p>	<p>innerHTML в IE9 (для таблиц) только для чтения</p>	<p>script вставленный с помощью innerHTML выполнен не будет</p><h4>outerHTML</h4><p>содержит HTML элемента целиком, не поддаётся изменению</p><h4>nodeValue/data</h4><p>содержимое текстового узла и комментариев, доступно на запись через data</p><h4>textContent</h4><p>содержит лишь текст внутри элемента, за вычетом всех <тегов></p><h4>hidden</h4><p>технически работает как атрибут style='display: none;'', но записывается короче и удобнее</p><h5>Исследование элементов</h5><p>	value - значение для INPUT, SELECT, TEXTAREA</p><p>	id - идентификатор</p><p>	href - адрес ссылки</p><p>	другие...</p>",
  "<h1>Работа с атрибутами элемента</h1>":"<h4>elem.hasAttribute(name);</h4><p>проверяет наличие атрибута</p><h4>elem.getAttribute(name);</h4><p>получает значение атрибута</p><h4>elem.setAttribute(name, value);</h4><p>устанавливает атрибут</p><h4>elem.removeAttribute(name);</h4><p>удаляет атрибут</p><h5>Особенности атрибутов:</h5><p>	Всегда являются строками</p><p>	Их имя нечувствительно к регистру</p><p>	Видны в innerHTML (за исключением старых IE)</p>",
  "<h1>Работа с классами элемента</h1>":"<h4>elem.classList.contains('class');</h4><p>возвращает true/false, в зависимости от того, есть ли у элемента класс 'class'.</p><h4>elem.classList.add/remove('class');</h4><p>добавляет/удаляет класс 'class'.</p><h4>elem.classList.toggle('class');</h4><p>если класса 'class' нет, добавляет его, если есть - удаляет.</p><h4>parent.contains('child');</h4><p>возвращает true, если child потомок parent, иначе false</p>",
  "<h1>Проверка на порядок вложенности</h1>":"<h4>nodeA.compareDocumentPosition(nodeB);</h4><p>возвращает битовую маску</p><h5>Битовая маска:</h5><p>Биты / Число / Значение</p><p>000000 / 0 / nodeA и nodeB - один и тот же узел</p><p>000001 / 1 / Узлы в разных документах (или один из них не в документе)</p><p>000010 / 2 / nodeB предшествует nodeA (в порядке обхода документа)</p><p>000100 / 4 / nodeA предшествует nodeB</p><p>001000 / 8 / nodeB содержит nodeA</p><p>010000 / 16 / nodeA содержит nodeB</p><p>100000 / 32 / Зарезервировано для браузера</p>",
  "<h1>Стандартная работа с узлами</h1>":"<h3>Создание элемента	</h3><h4>document.createElement(tag);</h4><p>создаёт новый элемент с указанным тегом</p><h4>document.createTextNode(text);</h4><p>создаёт текстовый узел</p><h3>Добавление эдемента в DOM</h3><h4>parentElem.appendChild(elem);</h4><p>добавляет elem в конец дочерних элементов parentElem</p><h4>parentElem.insertBefore(elem, nextSibling);</h4><p>добавляет elem перед nextSibling в parentElem</p><h3>Клонирование узлов</h3><h4>elem.cloneNode(true);</h4><p>вернёт глубокую копию элемента</p><h4>elem.cloneNode(false);</h4><p>вернёт копию без детей</p><h3>Удаление узлов</h3><h4>parentElem.removeChild(elem);</h4><p>удаляет elem из списка детей parentElem</p><h4>parentElem.replaceChild(newElem, elem);</h4><p>заменяет elem на newElem в списке детей parentElem</p>",
  "<h1>Мультивставка DOM-узлов</h1>":"<h4>elem.insertAdjacentHTML(where, html);</h4><p>вставляет произвольный html в любое место документа, в том числе и между узлами.</p><p>li.../li (1) li (2)elem(3) /li (4) li.../li</p><p>1. beforeBegin - вставит код до обёртки элемента</p><p>2. afterBegin - вставит код вначале элемента</p><p>3. beforeEnd - вставит код в конце элемента</p><p>4. afterEnd - вставит код после обёртки элемента</p>",
  "<h1>Быстрая работа с узлами</h1>":"<h4>elem.append(...nodes);</h4><p>вставляет nodes в конец node</p><h4>elem.prepend(...nodes);</h4><p>вставляет nodes в начало node</p><h4>elem.after(...nodes);</h4><p>вставляет nodes после узла node</p><h4>elem.before(...nodes);</h4><p>вставляет nodes перед узлом node</p><h4>elem.replaceWith(...nodes);</h4><p>вставляет nodes вместо node</p>",
  "<h1>Вписание строки в DOM на момент загрузки страницы</h1>":"<h4>document.write(str);</h4><p>вписывает строку в документ при загрузке HTML-страницы</p><h4>document.writeln(str);</h4><p>вписывает строку с переносом строки</p>",
  "<h1>Работа со стилями элементов</h1>":"<h4>Свойство style</h4><p>Свойство element.style возвращает объект, дающий доступ к стилю элемента на чтение и запись.</p><p>Единицы измерения ОБЯЗАТЕЛЬНЫ в style</p><p>Многословные свойства записываются без пробелов в верблюжьем регистре (CamelCase).</p>	<h5>style.width = '';</h5><p>Cтиль сбрасывается и берёт свои параметры из CSS.</p><h5>Префиксы:</h5><p>elem.style.MozBorderRadius = '5px';</p><p>elem.style.WebkitBorderRadius = '5px';</p><h4>Строка стилей style.cssText</h4><p>Свойство style является специальным объектом, ему нельзя присваивать строку, а вот свойство style.cssText позволяет поставить стиль целиком в виде строки.</p><h4>Получение текущего используемого значения свойства</h4><h5>window.getComputedStyle(elem[, pseudo]).</h5><p>elem - элемент, значение для которого нужно получить.</p><p>pseudo - указывается, если требуется стиль псевдо-элемента, например ::before, :hover.</p>",
  "<h1>Размеры и прокрутка элемента</h1>":"<h4>offsetParent</h4><p>находится ссылка на родительский элемент по позиционированию.</p><h4>offsetTop</h4><p>отступ от родителя по позиционированию сверху.</p><h4>offsetLeft</h4><p>отступ от родителя по позиционированию слева.</p><h4>offsetHeight</h4><p>внешняя высота элемента.</p><h4>offsetWidth</h4><p>внешняя ширина элемента.</p><h4>clientTop</h4><p>высота рамки.</p><h4>clientLeft</h4><p>ширина рамки.</p><h4>clientHeight</h4><p>внутренняя высота элемента без полосы прокрутки.</p><h4>clientWidth</h4><p>внутренняя ширина элемента без полосы прокрутки.</p><h4>scrollTop</h4><p>высота прокрученной области (от внутренней высоты).</p><h4>scrollLeft</h4><p>ширина прокрученной области (от внутренней ширины).</p><h4>scrollHeight</h4><p>внутренняя высота элемента с учётом полосы прокрутки.</p><h4>scrollWidth</h4><p>внутренняя ширина элемента с учётом полосы прокрутки.</p>",
  "<h1>Размеры и прокрутка страницы</h1>":"<h3>Ширина и высота видимой части окна</h3><p>Свойства clientHeight/Width - для элемента document.documentElement - это как раз высота/ширина видимой области окна.</p><p>window.innerWidth/Height - вся ширина/высота окна с полосой прокрутки.</p><h4>Получение текущей прокрутки</h4><p>Текущую прокрутку страницы можно получить запросом к documentElement.scrollLeft/Top или document.body.</p><h4>Методы для прокрутки </h4><h5>scrollBy(x,y)</h5><p>прокручивает страницу относительно текущих координат.</p><h5>scrollTo(pageX,pageY)</h5><p>прокручивает страницу к указанным координатам относительно документа.</p><h5>elem.scrollIntoView(top)</h5><p>вызывается на элементе и прокручивает страницу так, чтобы элемент оказался вверху, если параметр top равен true, и внизу, если top равен false.</p>",
  "<h1>Координаты в окне</h1>":"<p>Координатная система относительно окна браузера начинается в левом‑верхнем углу текущей видимой области окна.</p><h4>elem.getBoundingClientRect()</h4><p>возвращает координаты элемента, под которыми понимаются размеры 'воображаемого прямоугольника', который охватывает весь элемент.</p><p>top – Y‑координата верхней границы элемента</p><p>left – X‑координата левой границы</p><p>right – X‑координата правой границы</p><p>bottom – Y‑координата нижней границы</p><h4>document.elementFromPoint(x, y)</h4><p>возвращает элемент, находящийся на координатах (х, у) относительно окна (для координат вне окна метод возвратит null).</p>",
	"<h1>Координаты в документе</h1>":"\
	<p>Система координат относительно страницы или, иначе говоря, относительно документа, начинается в левом‑верхнем углу, но не окна, а именно страницы.</p>\
	<p></p>\
	<p>Готовой функции для получения координат элемента относительно страницы нет. Но её можно легко написать самим.</p>\
	<p></p>\
	<p>function getCoords(elem) { // кроме IE8‐</p>\
	<p> var box = elem.getBoundingClientRect();</p>\
	<p> return {</p>\
	<p>   top: box.top + pageYOffset,</p>\
	<p>   left: box.left + pageXOffset</p>\
	<p> };</p>\
	<p>}</p>","\
	<h1>Координаты на экране screenX, screenY</h1>":"\
	<h4>Размеры экрана хранятся в глобальной переменной screen:</h4>\
	<p>Общая ширина/высота</p>\
	<p>alert( screen.width + ' x ' + screen.height );</p>\
	<p></p>\
	<p>Доступная ширина/высота (за вычетом таскбара и т.п.)</p>\
	<p>alert( screen.availWidth + ' x ' + screen.availHeight );</p>\
	<p> </p>\
	<p>Есть и ряд других свойств screen (см. документацию)</p>\
	<p> </p>\
	<h4>Координаты левого‑верхнего угла браузера на экране хранятся в window.screenX, window.screenY (не поддерживаются IE8‑):</h4>\
	<p></p>\
	<p>alert( 'Браузер находится на ' + window.screenX + ',' + window.screenY );</p><i>Они могут быть и меньше нуля, если окно частично вне экрана.</i>\
	<p></p>\
	<p>Заметим, что общую информацию об экране и браузере получить можно, а вот координаты конкретного элемента на экране – нельзя, нет аналога <b>getBoundingClientRect</b> или иного метода для этого.</p>","\
	<h1>Обработчики</h1>":"\
	<p>Для реакции на действия посетителя и внутреннего взаимодействия скриптов существуют события.</p>\
	<p></p>\
	<p>Событие - это сигнал от браузера о том, что что-то произошло.</p>\
	<p></p>\
	<p>Событию можно назначить обработчик, то есть функцию, которая сработает, как только событие произошло.</p>\
	<p></p>\
	<p>Благодаря обработчикам JS может реагировать на действия посетителя.</p>\
	<p></p>\
	<p>Есть несколько способов назначить событию обработчик:</p>\
	<p></p>\
	<h5>1. Использование атрибута HTML [<b>on + событие</b>]</h5>\
	<p>// Позволяет назначить один обработчик</p>\
	<p>onclick='alert('Hi!')'</p>\
	<h5>2. Использование свойства DOM-объекта</h5>\
	<p>Позволяет назначить один обработчик, новый затрёт</p>\
	<p>elem.onclick = function(){...}</p>\
	<p>Убрать обработчик можно значением: elem.onclick = null;</p>\
	<h5>addEventListener и removeEventListener</h5>\
	<p>Позволяет назначать сколько угодно обработчиков</p>\
	<p>element.addEventListener(event, handler[, phase]);</p>\
	<p>* event - событие (click)</p>\
	<p>* handler - ссылка на функцию, которую нужно поставить в обработчик</p>\
	<p>* phase - фаза, на которой обработчик должен сработать</p>\
	<p></p>\
	<p>Удаление обработчика осуществляется вызовом:</p>\
	<p></p>\
	<p>element.removeEventListener(event, handler[, phase]);</p>\
	<p>// Необходимо передать те же аргументы, что были переданы в add-обработчик</p>\
	<p>// Удаление требует ту же функцию, это важно!</p>","\
	<h1>Объект события</h1>":"\
	<p>Чтобы хорошо обработать событие, недостаточно знать о том, что это за - 'клик' или 'нажатие клавиши'. Могут понадобиться детали: координаты курсора, введённые символы и другие, в зависимости от события.</p>\
	<p></p>\
	<p>Детали произошедшего браузер записывает в 'объект события', который передаётся первым аргументом в обработчик.</p>\
	<p></p>\
	<h4>Свойства объекта события(некоторые из них):</h4>\
	<p></p>\
	<h5>event.type </h5>\
	<p>тип события (например: click)</p>\
	<h5>event.currentTarget </h5>\
	<p>элемент, на котором сработал обработчик (значение, как и у this)</p>\
	<h5>event.clientX / event.clientY </h5>\
	<p>координаты курсора в момент клика (относительно окна)</p>","\
	<h1>Всплытие и перехват</h1>":"\
	<p>Всплытие - это когда при наступлении события, обработчик сперва срабатывает на самом вложенном элементе, затем на его родителе, затем выше и т.д., вверх по цепочке вложенности.</p>\
	<p></p><i>Всплывают почти все события (focus - не всплывает)</i>\
	<p></p>\
	<h4>Целевой элемент event.target</h4>\
	<p>На каком бы элементе мы ни поймали событие, всегда можно узнать, где конкретно оно произошло.</p>\
	<p></p>\
	<p>Самый глубокий элемент, который вызывает событие, называется <b>'целевым'</b> или <b>'исходным'</b> элементом и доступен как <b>event.target</b>.</p>\
	<p></p>\
	<p>Отличия:</p>\
	<p> </p>\
	<h5>event.target </h5>\
	<p>это исходный элемент, на котором произошло событие, в процессе всплытия он неизменен.</p>\
	<h5>this</h5>\
	<p>это текущий элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.</p>","\
	<h1>Прекращение всплытия</h1>":"\
	<p>Всплывающее событие будет всплывать вверх, до wndow, вызывая походу все обработчики. Но любой промежуточный обработчик способен решить, что событие полностью обработано, и остановить всплытие.</p>\
	<p></p>\
	<p>Для остановки всплытия нужно вызвать метод</p>\
	<p></p>\
	<h4>event.stopPropagation()</h4>","\
	<h1>Полное прекращение работы событий</h1>":"\
	<p>Для полной остановки обработки, современные браузеры поддерживают метод <b>event.stopImmediatePropagation()</b>. Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.</p>\
	<p></p><i>Не стоит прекращать всплытие без особой необходимости, им могут пользоваться другие скрипты.</i>","\
	<h1>Погружение</h1>":"\
	<p>В современном стандарте, кроме «всплытия» событий, предусмотрено ещё и «погружение». Оно гораздо менее востребовано, но иногда, очень редко, знание о нём может быть полезным.</p>\
	<p></p>\
	<p>Строго говоря, стандарт выделяет целых три стадии прохода события:</p>\
	<p></p>\
	<p>1. Событие сначала идет сверху вниз. Эта стадия называется «стадия перехвата» (capturing stage).</p>\
	<p>2. Событие достигло целевого элемента. Это – «стадия цели» (target stage).</p>\
	<p>3. После этого событие начинает всплывать. Это – «стадия всплытия» (bubbling stage).</p>\
	<p>Чтобы поймать событие на стадии перехвата, нужно использовать третий аргумент <b>addEventListener</b>:</p>\
	<p></p>\
	<p>Если аргумент <b>true</b> , то событие будет перехвачено по дороге вниз.</p>\
	<p>Если аргумент <b>false</b> , то событие будет поймано при всплытии.</p>\
	<p></p>\
	<p>Алгоритм:</p>\
	<p></p>\
	<p>1. При наступлении события – элемент, на котором оно произошло, помечается как «целевой» (event.target ).</p>\
	<p>2. Далее событие сначала двигается вниз от корня документа к event.target , по пути вызывая обработчики, поставленные через addEventListener(...., true).</p>\
	<p>3. Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on* и addEventListener(...., false) .</p>\
	<p></p>\
	<p>Каждый обработчик имеет доступ к свойствам события:</p>\
	<p></p>\
	<p>1. event.target – самый глубокий элемент, на котором произошло событие.</p>\
	<p>2. event.currentTarget (= this ) – элемент, на котором в данный момент сработал обработчик (до которого «доплыло» событие).</p>\
	<p>3. event.eventPhase – на какой фазе он сработал (погружение =1, всплытие = 3).</p>\
	<p>Любой обработчик может остановить событие вызовом event.stopPropagation() , но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.</p>","\
	<h1>Делегирование событий</h1>":"\
	<p>Всплытие событий позволяет реализовать один из самых важных приёмов разработки – делегирование. Он заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому – мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент event.target , понять на каком именно потомке произошло событие и обработать его.</p>","\
	<h1>Действия браузера по умолчанию</h1>":"\
	<p>Многие события автоматически влекут за собой действие браузера. </p>\
	<p>Например:</p>\
	<p></p>\
	<p>* Клик по ссылке инициирует переход на новый URL.</p>\
	<p>* Нажатие на кнопку «отправить» в форме – отсылку ее на сервер.</p>\
	<p>* Двойной клик на тексте – инициирует его выделение.</p>\
	<p>Если мы обрабатываем событие в JavaScript, то зачастую такое действие браузера нам не нужно. К счастью, его можно отменить.</p>\
	<p></p>\
	<p>Есть два способа отменить действие браузера:</p>\
	<p></p>\
	<p>* Основной способ – это воспользоваться объектом события. Для отмены действия браузера существует стандартный метод event.preventDefault().</p>\
	<p>* Если же обработчик назначен через onсобытие (не через addEventListener), то можно просто вернуть false из обработчика.</p>\
	<p>Обработка клика в JS, но запрет самого действия на примере ссылки:</p>\
	<p> </p>\
	<p>\
		menu.onclick = function(event) {<br>\	  if (event.target.nodeName != 'A') return;<br>\
			<br>\
		 var href = event.target.getAttribute('href');<br>\
		 alert( href ); // может быть подгрузка с сервера, генерация интерфейса и т.п.<br>\
			<br>\
		 return false; // отменить переход по url<br>\
		};\
	</p>","\
	<h1>Другие действия браузера</h1>":"\
	<p>Действий браузера по умолчанию достаточно много.</p>\
	<p></p>\
	<p>Вот некоторые примеры событий, которые вызывают действие браузера:</p>\
	<p></p>\
	<p>* mousedown – нажатие кнопкой мыши в то время как курсор находится на тексте начинает его выделение.</p>\
	<p>* click на – ставит или убирает галочку.</p>\
	<p>* submit – при нажатии на в форме данные отправляются на сервер.</p>\
	<p>* wheel – движение колёсика мыши инициирует прокрутку.</p>\
	<p>* keydown – при нажатии клавиши в поле ввода появляется символ.</p>\
	<p>* contextmenu – при правом клике показывается контекстное меню браузера.</p>\
	<p>* …</p>\
	<p>Все эти действия можно отменить, если мы хотим обработать событие исключительно при помощи JavaScript.</p>","\
	<h1>Генерация событий на элементах</h1>":"\
	<p>Можно не только назначать обработчики на события, но и генерировать их самому. Мы будем использовать это позже для реализации компонентной архитектуры, при которой элемент, представляющий собой, к примеру, меню, генерирует события, к этому меню относящиеся – select (выбран пункт меню) или open (меню раскрыто), и другие. Кроме того, события можно генерировать для целей автоматического тестирования.</p>","\
	<h1>Конструктор Event</h1>":"\
	<p>Вначале рассмотрим современный способ генерации событий, по стандарту DOM 4. Он поддерживается всеми браузерами, кроме IE11‑. А далее рассмотрим устаревшие варианты, поддерживаемые IE.</p>\
	<p></p>\
	<p>Объект события в нём создаётся при помощи встроенного конструктора Event. Синтаксис:</p>\
	<p> </p>\
	<p>var event = new Event(тип события[, флаги]);</p>\
	<p></p>\
	<p>Где:</p>\
	<p></p>\
	<p>* <b>Тип события</b> – может быть как своим, так и встроенным, к примеру 'click' .</p>\
	<p>* <b>Флаги</b> – объект вида { bubbles: true/false, cancelable: true/false } , где свойство bubbles указывает, всплывает ли событие, а cancelable – можно ли отменить действие по умолчанию.</p>\
	<p>* Флаги по умолчанию: {bubbles: false, cancelable: false} .</p>","\
	<h1>Метод dispatchEvent</h1>":"\
	<p>Затем, чтобы инициировать событие, запускается <b>elem.dispatchEvent(event)</b>.</p>\
	<p></p>\
	<p>При этом событие срабатывает наравне с браузерными, то есть обычные браузерные обработчики на него отреагируют. Если при создании указан флаг bubbles , то оно будет всплывать.</p>\
	<p></p>\
	<p>При просмотре примера ниже кнопка обработчик onclick на кнопке сработает сам по себе, событие генерируется скриптом:</p>\
	<p></p>\
	<p>\
		\<\button id='elem' onclick='alert('Клик');'>Автоклик\<\/button>\<\script><br>\
			var event = new Event('click');<br>\
			elem.dispatchEvent(event);<br>\
		\<\/script>\
	</p>\
	","\
	<h1>Отмена действия по умолчанию</h1>":"\
	<p>На сгенерированном событии, как и на встроенном браузерном, обработчик может вызвать метод <b>event.preventDefault()</b>. Тогда <b>dispatchEvent</b> возвратит <b>false</b>.</p>\
	<p></p>\
	<p>Остановимся здесь подробнее. Обычно preventDefault() вызов предотвращает действие браузера. В случае, если событие придумано нами, имеет нестандартное имя – никакого действия браузера, конечно, нет.</p>\
	<p></p>\
	<p>Но код, который генерирует событие, может предусматривать какие‑то ещё действия после <b>dispatchEvent</b>.</p>\
	<p></p>\
	<p>Вызов event.preventDefault() является возможностью для обработчика события сообщить в сгенерировавший событие код, что эти действия продолжать не надо.</p>\
	<p></p>\
	<h6>Как отличить реальное нажатие от скриптового?</h6>\
	<p>В целях безопасности иногда хорошо бы знать – инициировано ли действие посетителем или это кликнул скрипт. Единственный способ, которым код может отличить реальное нажатие от программного, является проверка свойства event.isTrusted. Оно на момент написания статьи поддерживается IE и Firefox и равно true, если посетитель кликнул сам, и всегда false – если событие инициировал скрипт.</p>","\
	<h1>Другие свойства событий</h1>":"\
	<p>При создании события браузер автоматически ставит следующие свойства:</p>\
	<p></p>\
	<h5>isTrusted: </h5>\
	<p>false -  означает, что событие сгенерировано скриптом, это свойство изменить невозможно.</p>\
	<h5>target: </h5>\
	<p>null - это свойство ставится автоматически позже при dispatchEvent.</p>\
	<h5>type: </h5>\
	<p>тип события – первый аргумент new Event.</p>\
	<h5>bubbles, cancelable </h5>\
	<p>по второму аргументу new Event.</p>\
	<p>Другие свойства события, если они нужны, например координаты для события мыши – можно присвоить в объект события позже, например:</p>\
	<p></p>\
	<p>var event = new Event('click', {bubbles: true, cancelable: false});</p>\
	<p>event.clientX = 100;</p>\
	<p>event.clientY = 100;</p>","\
	<h1>Пример со всплытием</h1>":"\
	<p>Сгенерируем совершенно новое событие 'hello' и поймаем его на document.</p>\
	<p></p>\
	<p>Всё, что для этого нужно – это флаг <b>bubbles</b> :</p>\
	<p> </p>\
	<p>\
		\<\h1 id='elem'>Привет от скрипта!\<\/h1><br>\\<\script><br>\
			document.addEventListener('hello', function(event) { // (1)<br>\
				alert('Привет');<br>\
				event.preventDefault(); // (2)<br>\
			}, false);<br>\
			var event = new Event('hello', {bubbles: true, cancelable: true}); // (3)<br>\
			if (elem.dispatchEvent(event) === false) {<br>\
				alert('Событие было отменено preventDefault');<br>\
			}<br>\
		\<\/script>\
	</p>\
	<p>Обратите внимание:</p>\
	<p> </p>\
	<p>1. Обработчик события hello стоит на document . Мы его поймаем на всплытии.</p>\
	<p>2. Вызов event.preventDefault() приведёт к тому, что dispatchEvent вернёт false.</p>\
	<p>3. Чтобы событие всплывало и его можно было отменить, указан второй аргумент new Event.</p>\
	<p>Никакой разницы между встроенными событиями ( click ) и своими ( hello ) здесь нет, их можно сгенерировать и запустить совершенно одинаково.</p>","\
	<h1>Конструкторы MouseEvent, KeyboardEvent и другие</h1>":"\
	<p>Для некоторых конкретных типов событий есть свои, специфические, конструкторы.</p>\
	<p> </p>\
	<p>Вот список конструкторов для различных событий интерфейса, которые можно найти в спецификации UI Event:</p>\
	<p>* UIEvent</p>\
	<p>* FocusEvent</p>\
	<p>* MouseEvent</p>\
	<p>* WheelEvent</p>\
	<p>* KeyboardEvent</p>\
	<p>* CompositionEvent</p>\
	<p></p>\
	<p>Вместо new Event('click') можно вызвать new MouseEvent('click').</p>\
	<p></p>\
	<p>Специфический конструктор позволяет указать стандартные свойства для данного типа события. Например, clientX/clientY для события мыши:</p>\
	<p> </p>\
	<p>\
		var e = new MouseEvent('click', {<br>\	  bubbles: true,<br>\
				cancelable: true,<br>\
				clientX: 100,<br>\
				clientY: 100<br>\
			});<br>\
			alert( e.clientX ); // 100\
	</p>\
	<p>Это нельзя было бы сделать с обычным конструктором Event:</p>\
	<p> </p>\
	<p>\
		var e = new Event('click', {<br>\		bubbles: true,<br>\
				cancelable: true,<br>\
				clientX: 100,<br>\
				clientY: 100<br>\
			});<br>\
			alert( e.clientX ); // undefined, свойство не присвоено!<br>\
	</p>\
	<p>Обычный конструктор Event не знает про «мышиные» свойства, поэтому их игнорирует.</p>\
	<p> </p>\
	<p>Впрочем, использование конкретного конструктора не является обязательным, можно обойтись Event , а свойства записать в объект отдельно, после конструктора. Здесь это скорее вопрос удобства и желания следовать правилам. События, которые генерирует браузер, всегда имеют правильный тип.</p>","\
	<h1>Свои события</h1>":"\
	<p>Для генерации своих, нестандартных, событий, хоть и можно использовать конструктор Event , но существует и специфический конструктор <b>CustomEvent</b>. Технически, он абсолютно идентичен Event , кроме небольшой детали: у второго аргумента‑объекта есть дополнительное свойство <b>detail</b>, в котором можно указывать информацию для передачи в событие.</p>\
	<p></p>\
	<p>Например:</p>\
	<p> </p>\
	<p>\
		\<\h1 id='elem'>Привет для Васи!\<\/h1><br>\	\<\script><br>\
				elem.addEventListener('hello', function(event) {<br>\
					alert( event.detail.name );<br>\
				}, false);<br>\
		<br>\
				var event = new CustomEvent('hello', {<br>\
					detail: { name: 'Вася' }<br>\
				});<br>\
		<br>\
				elem.dispatchEvent(event);<br>\
			\<\/script>\
	</p>\
	<p>Надо сказать, что никто не мешает и в обычное Event записать любые свойства. Но CustomEvent более явно говорит, что событие не встроенное, а своё, и выделяет отдельно «информационное» поле detail , в которое можно записать что угодно без конфликта со стандартными свойствами объекта.</p>","\
	<h1>Мышь: клики, кнопка, координаты</h1>":"\
	<h4>mousedown</h4>\
	<p>Кнопка мыши нажата над элементом.</p>\
	<h4>mouseup </h4>\
	<p>Кнопка мыши отпущена над элементом.</p>\
	<h4>mouseover </h4>\
	<p>Мышь появилась над элементом.</p>\
	<h4>mouseout </h4>\
	<p>Мышь ушла с элемента.</p>\
	<h4>mousemove </h4>\
	<p>Каждое движение мыши над элементом генерирует это событие.</p>\
	<h4>click </h4>\
	<p>Вызывается при клике мышью, то есть при mousedown , а затем mouseup на одном элементе</p>\
	<h4>contextmenu </h4>\
	<p>Вызывается при клике правой кнопкой мыши на элементе.</p>\
	<h4>dblclick </h4>\
	<p>Вызывается при двойном клике по элементу.</p>\
	<p></p>\
	<p>Получение информации о кнопке мыши через свойство which объекта event:</p>\
	<p></p>\
	<h5>event.which == 1 – левая кнопка</h5>\
	<h5>event.which == 2 – средняя кнопка</h5>\
	<h5>event.which == 3 – правая кнопка</h5>\
	<p>Во всех событиях мыши присутствует информация о нажатых клавишах‑модификаторах.</p>\
	<p></p>\
	<h5>shiftKey</h5>\
	<h5>altKey</h5>\
	<h5>ctrlKey</h5>\
	<h5>metaKey (для Mac)</h5>\
	<p>Все мышиные события предоставляют текущие координаты курсора в двух видах: относительно окна и относительно документа.</p>\
	<p> </p>\
	<p>Пара свойств <b>clientX/clientY</b> содержит координаты курсора относительно текущего окна.</p>\
	<p><i>При этом, например, если ваше окно размером 500x500, а мышь находится в центре, тогда и clientX и clientY будут равны 250. Можно как угодно прокручивать страницу, но если не двигать при этом мышь, то координаты курсора clientX/clientY не изменятся, потому что они считаются относительно окна, а не документа. В той же системе координат работает и метод elem.getBoundingClientRect() , возвращающий координаты элемента, а также position:fixed.</i></p>\
	<p></p>\
	<p>Координаты курсора относительно документа находятся в свойствах <b>pageX/pageY</b>.</p>\
	<p><i>Так как эти координаты – относительно левого‑верхнего узла документа, а не окна, то они учитывают прокрутку. Если прокрутить страницу, а мышь не трогать, то координаты курсора pageX/pageY изменятся на величину прокрутки, они привязаны к конкретной точке в документе.</i></p>\
	<p> </p>\
	<p>События мыши имеют следующие свойства:</p>\
	<p> </p>\
	<p>* Кнопка мыши: which (для IE8‑: нужно ставить из button )</p>\
	<p>* Элемент, вызвавший событие: target</p>\
	<p>* Координаты, относительно окна: clientX/clientY</p>\
	<p>* Координаты, относительно документа: pageX/pageY (для IE8‑: нужно ставить по clientX/Y и прокрутке)</p>\
	<p>* Если зажата спец. клавиша, то стоит соответствующее свойство: altKey , ctrlKey , shiftKey или metaKey (Mac).</p>\
	<p>* Для поддержки Ctrl + click не забываем проверить if (e.metaKey || e.ctrlKey) , чтобы пользователи Mac тоже были довольны.</p>","\
	<h1>Отмена выделения, невыделяемые элементы</h1>":"\
	<h6>1. Отмена mousedown/selectstart </h6>\
	<p>\
		\<\div ondblclick='alert('Тест')' onselectstart='return false' onmousedown='return false'\><br>\
		Двойной клик сюда выведет 'Тест', без выделения <br>\
			\<\/div>\
	</p>\
	<h6>2. Снятие выделения постфактум</h6>\
	<p>\
		\<ul><br>\
		\<\li ondblclick='clearSelection()'>Выделение отменяется при двойном клике.</li><br>\
			\<\/ul><br>\
			\<\script><br>\
				function clearSelection() {<br>\
					if (window.getSelection) {<br>\
						window.getSelection().removeAllRanges();<br>\
					} else { // старый IE<br>\
						document.selection.empty();<br>\
					}<br>\
				}<br>\
			\<\/script>\
	</p>\
	<h6>3. Свойство user-select</h6>\
	<p>\
		\<\style><br>\	  b {<br>\
					‐webkit‐user‐select: none;<br>\
					/* user‐select ‐‐ это нестандартное свойство */<br>\
			<br>\
					‐moz‐user‐select: none;<br>\
					/* поэтому нужны префиксы */<br>\
			<br>\
					‐ms‐user‐select: none;<br>\
				}<br>\
			\<\/style><br>\
			<br>\
		Строка до..<br>\
			\<\div ondblclick='alert('Тест')'><br>\
				\<\b>Этот текст нельзя выделить (кроме IE9‐)\<\/b><br>\
			\<\/div><br>\
		.. Строка после\
	</p>\
	<h6>4. Если хочется запретить копирование – можно использовать событие <b>oncopy='return false'</b></h6>'","\
	<h1>Мышь: движение mouseover/out, mouseenter/leave</h1>":"\
	<p>В обработчике события mouseover:</p>\
	<p> </p>\
	<h4>event.target </h4>\
	<p>элемент, на который пришла мышь, то есть на котором возникло событие.</p>\
	<h4>event.relatedTarget </h4>\
	<p>элемент, с которого пришла мышь.</p>\
	<p>Для <b>mouseout</b> всё наоборот:</p>\
	<p></p>\
	<h4>event.target </h4>\
	<p>элемент, с которого ушла мышь, то есть на котором возникло событие.</p>\
	<h4>event.relatedTarget </h4>\
	<p>элемент, на который перешла мышь.</p>\
	<p></p>\
	<p>События mouseenter/mouseleave похожи на mouseover/mouseout. Они тоже срабатывают, когда курсор заходит на элемент и уходит с него, но с двумя отличиями.</p>\
	<p>1. Не учитываются переходы внутри элемента.</p>\
	<p>2. События mouseenter/mouseleave не всплывают.</p>\
	<p>Эти события более интуитивно понятны. Курсор заходит на элемент – срабатывает mouseenter, а затем – неважно, куда он внутри него переходит, mouseleave будет, когда курсор окажется за пределами элемента.</p>\
	<p></p>\
	<p>События mouseenter/leave более наглядны и понятны, но они не всплывают, а значит с ними нельзя использовать делегирование.</p>","\
	<h1>Алгоритм Drag’n’Drop</h1>":"\
	<p>Основной алгоритм Drag’n’Drop выглядит так:</p>\
	<p></p>\
	<p>1. Отслеживаем нажатие кнопки мыши на переносимом элементе при помощи события mousedown.</p>\
	<p>2. При нажатии – подготовить элемент к перемещению.</p>\
	<p>3. Далее отслеживаем движение мыши через mousemove и передвигаем переносимый элемент на новые координаты путём смены left/top и position:absolute .</p>\
	<p>4. При отпускании кнопки мыши, то есть наступлении события mouseup – остановить перенос элемента и произвести все действия, связанные с окончанием Drag’n’Drop.</p>\
	<p>В следующем примере эти шаги реализованы для переноса мяча:</p>\
	<p>\
		var ball = document.getElementById('ball');<br>\	ball.onmousedown = function(e) { // 1. отследить нажатие<br>\
		<br>\
				// подготовить к перемещению<br>\
				// 2. разместить на том же месте, но в абсолютных координатах<br>\
				ball.style.position = 'absolute';<br>\
				moveAt(e);<br>\
				// переместим в body, чтобы мяч был точно не внутри position:relative<br>\
				document.body.appendChild(ball);<br>\
		<br>\
				ball.style.zIndex = 1000; // показывать мяч над другими элементами<br>\
		<br>\
				// передвинуть мяч под координаты курсора<br>\
				// и сдвинуть на половину ширины/высоты для центрирования<br>\
				function moveAt(e) {<br>\
					ball.style.left = e.pageX ‐ ball.offsetWidth / 2 + 'px';<br>\
					ball.style.top = e.pageY ‐ ball.offsetHeight / 2 + 'px';<br>\
				}<br>\
		<br>\
				// 3, перемещать по экрану<br>\
				document.onmousemove = function(e) {<br>\
					moveAt(e);<br>\
				}<br>\
		<br>\
				// 4. отследить окончание переноса<br>\
				ball.onmouseup = function() {<br>\
					document.onmousemove = null;<br>\
					ball.onmouseup = null;<br>\
				}<br>\
		<br>\
				//5. Отключить Drag`n`Drop Браузера<br>\
				ball.ondragstart = function() {<br>\
					return false;<br>\
				};<br>\
			}\
	</p>","\
	<h1>Правильное позиционирование при DragnDrop</h1>":"\
	<p>\
		var ball = document.getElementById('ball');<br>\	ball.onmousedown = function(e) {<br>\
				var coords = getCoords(ball);<br>\
				var shiftX = e.pageX ‐ coords.left;<br>\
				var shiftY = e.pageY ‐ coords.top;<br>\
				<br>\
				ball.style.position = 'absolute';<br>\
				document.body.appendChild(ball);<br>\
				moveAt(e);<br>\
		<br>\
				ball.style.zIndex = 1000; // над другими элементами<br>\
		<br>\
				function moveAt(e) {<br>\
					ball.style.left = e.pageX ‐ shiftX + 'px';<br>\
					ball.style.top = e.pageY ‐ shiftY + 'px';<br>\
				}<br>\
		<br>\
				document.onmousemove = function(e) {<br>\
					moveAt(e);<br>\
				};<br>\
		<br>\
				ball.onmouseup = function() {<br>\
					document.onmousemove = null;<br>\
					ball.onmouseup = null;<br>\
				};<br>\
			}<br>\
			ball.ondragstart = function() {<br>\
				return false;<br>\
			};<br>\
	</p>","\
	<h1>Колёсико мыши, событие wheel</h1>":"\
	<p>Событие wheel появилось в стандарте не так давно. Оно поддерживается Chrome 31+, IE9+, Firefox 17+. До него браузеры обрабатывали прокрутку при помощи событий mousewheel (все кроме Firefox) и DOMMouseScroll , MozMousePixelScroll (только Firefox).</p>\
	<p></p>\
	<p>Самые важные свойства современного события и его нестандартных аналогов:</p>\
	<p></p>\
	<p>wheel - Свойство deltaY – количество прокрученных пикселей по горизонтали и вертикали. Существуют также свойства deltaX и deltaZ для других направлений прокрутки.</p>\
	<p>MozMousePixelScroll - Срабатывает, начиная с Firefox 3.5, только в Firefox. Даёт возможность отменить прокрутку и получить размер в пикселях через свойство detail , ось прокрутки в свойстве axis.</p>\
	<p>mousewheel - Срабатывает в браузерах, которые ещё не реализовали wheel .</p>\
	<p>wheelDelta – В этом свойстве находится условный «размер прокрутки», обычно равный 120 для прокрутки вверх и ‐120 – вниз. Он не соответствует какому‑либо конкретному количеству пикселей.</p>","\
	<h1>Прокрутка, событие scroll</h1>":"\
	<p>Событие onscroll происходит, когда элемент прокручивается.</p>\
	<p></p>\
	<p>В отличие от события onwheel (колесико мыши), его могут генерировать только прокручиваемые элементы или окно window . Но зато оно генерируется всегда, при любой прокрутке, не обязательно «мышиной».</p>\
	<p></p>\
	<p>Некоторые области применения onscroll :</p>\
	<p></p>\
	<p>* Показ дополнительных элементов навигации при прокрутке.</p>\
	<p>* Подгрузка и инициализация элементов интерфейса, ставших видимыми после прокрутки.</p>"
};

// Задачи
var js3 = {
	
};